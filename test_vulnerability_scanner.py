import unittest
import os
from unittest.mock import patch, MagicMock
from EthicalSecurityTools.tools.vulnerability_scanner import VulnerabilityScanner

class TestVulnerabilityScanner(unittest.TestCase):
    def setUp(self):
        self.scanner = VulnerabilityScanner()
        self.scanner.log_file = "test_vulnerability_scanner.log" # Redirect log for testing
        if os.path.exists(self.scanner.log_file):
            os.remove(self.scanner.log_file)

    def tearDown(self):
        if os.path.exists(self.scanner.log_file):
            os.remove(self.scanner.log_file)

    @patch("socket.socket")
    def test_scan_port_open(self, mock_socket):
        mock_sock_instance = MagicMock()
        mock_socket.return_value = mock_sock_instance
        mock_sock_instance.connect_ex.return_value = 0 # Simulate open port
        
        self.assertTrue(self.scanner.scan_port("localhost", 80))
        mock_sock_instance.connect_ex.assert_called_with(("localhost", 80))

    @patch("socket.socket")
    def test_scan_port_closed(self, mock_socket):
        mock_sock_instance = MagicMock()
        mock_socket.return_value = mock_sock_instance
        mock_sock_instance.connect_ex.return_value = 111 # Simulate closed port
        
        self.assertFalse(self.scanner.scan_port("localhost", 8080))

    @patch("socket.socket")
    def test_scan_common_ports(self, mock_socket):
        mock_sock_instance = MagicMock()
        mock_socket.return_value = mock_sock_instance
        # Simulate port 80 and 443 open, others closed
        mock_sock_instance.connect_ex.side_effect = lambda host, port: 0 if port in [80, 443] else 111
        
        open_ports = self.scanner.scan_common_ports("localhost")
        self.assertIn(80, open_ports)
        self.assertIn(443, open_ports)
        self.assertEqual(len(open_ports), 2)

    @patch("requests.get")
    def test_check_xss_vulnerable(self, mock_get):
        mock_response = MagicMock()
        mock_response.text = "<html><script>alert(\'XSS\')</script></html>"
        mock_get.return_value = mock_response
        
        self.assertTrue(self.scanner.check_xss("http://example.com"))
        mock_get.assert_called_with("http://example.com<script>alert(\'XSS\')</script>")

    @patch("requests.get")
    def test_check_xss_not_vulnerable(self, mock_get):
        mock_response = MagicMock()
        mock_response.text = "<html>Clean</html>"
        mock_get.return_value = mock_response
        
        self.assertFalse(self.scanner.check_xss("http://example.com"))

    @patch("requests.get")
    def test_check_sql_injection_vulnerable(self, mock_get):
        mock_response = MagicMock()
        mock_response.text = "Error: SQL syntax near 'OR 1=1'"
        mock_get.return_value = mock_response
        
        self.assertTrue(self.scanner.check_sql_injection("http://example.com/login.php"))
        mock_get.assert_called_with("http://example.com/login.php?id=' OR 1=1 -- ")

    @patch("requests.get")
    def test_check_sql_injection_not_vulnerable(self, mock_get):
        mock_response = MagicMock()
        mock_response.text = "Login successful"
        mock_get.return_value = mock_response
        
        self.assertFalse(self.scanner.check_sql_injection("http://example.com/login.php"))

if __name__ == '__main__':
    unittest.main()

