#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ماسح الثغرات الأمنية - Vulnerability Scanner
إصدار: 2.0
"""

import requests
import socket
import platform
import time
from urllib.parse import urlparse
from colorama import init, Fore

init()

class VulnerabilityScanner:
    def __init__(self):
        self.log_file = "vulnerability_scan.log"
        self.os_type = platform.system()
        self.log("Vulnerability Scanner initialized", "INFO")

    def scan_port(self, host, port):
        """
        فحص منفذ معين على المضيف
        :param host: عنوان IP أو اسم المضيف
        :param port: رقم المنفذ
        :return: True إذا كان المنفذ مفتوحاً، False خلاف ذلك
        """
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)  # مهلة ثانية واحدة
            result = sock.connect_ex((host, port))
            if result == 0:
                self.log(f"Port {port} on {host} is OPEN", "SUCCESS")
                return True
            else:
                self.log(f"Port {port} on {host} is CLOSED", "INFO")
                return False
        except socket.gaierror:
            self.log(f"Hostname {host} could not be resolved.", "ERROR")
            return False
        except socket.error as e:
            self.log(f"Could not connect to server {host}: {str(e)}", "ERROR")
            return False

    def scan_common_ports(self, host):
        """
        فحص المنافذ الشائعة على المضيف
        :param host: عنوان IP أو اسم المضيف
        :return: قائمة بالمنافذ المفتوحة
        """
        common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 3389, 8080]
        open_ports = []
        self.log(f"Scanning common ports on {host}...", "INFO")
        for port in common_ports:
            if self.scan_port(host, port):
                open_ports.append(port)
        return open_ports

    def check_xss(self, url, payload="<script>alert(\'XSS\')</script>"):
        """
        فحص ثغرات XSS الأساسية
        :param url: الرابط المراد فحصه
        :param payload: حمولة XSS للاختبار
        :return: True إذا تم العثور على ثغرة، False خلاف ذلك
        """
        self.log(f"Checking XSS on {url} with payload: {payload}", "INFO")
        try:
            response = requests.get(url + payload)
            if payload in response.text:
                self.log(f"XSS vulnerability detected in {url}", "WARNING")
                return True
            else:
                self.log(f"No XSS vulnerability detected in {url}", "INFO")
                return False
        except requests.exceptions.RequestException as e:
            self.log(f"Error checking XSS for {url}: {str(e)}", "ERROR")
            return False

    def check_sql_injection(self, url, payload="\' OR 1=1 -- "):
        """
        فحص ثغرات SQL Injection الأساسية
        :param url: الرابط المراد فحصه
        :param payload: حمولة SQLi للاختبار
        :return: True إذا تم العثور على ثغرة، False خلاف ذلك
        """
        self.log(f"Checking SQL Injection on {url} with payload: {payload}", "INFO")
        try:
            # محاولة حقن في معلمة URL
            parsed_url = urlparse(url)
            if parsed_url.query:
                test_url = url + payload
            else:
                test_url = url + "?id=" + payload # افتراض معلمة 'id'

            response = requests.get(test_url)
            # علامات شائعة تدل على SQLi
            if "SQL syntax" in response.text or "mysql_fetch_array" in response.text or "Warning: mysql_" in response.text:
                self.log(f"SQL Injection vulnerability detected in {url}", "WARNING")
                return True
            else:
                self.log(f"No SQL Injection vulnerability detected in {url}", "INFO")
                return False
        except requests.exceptions.RequestException as e:
            self.log(f"Error checking SQL Injection for {url}: {str(e)}", "ERROR")
            return False

    def log(self, message, level="INFO"):
        """تسجيل الأحداث مع تصنيف مستوى الخطورة"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        
        colors = {
            "INFO": Fore.BLUE,
            "WARNING": Fore.YELLOW,
            "ERROR": Fore.RED,
            "SUCCESS": Fore.GREEN
        }
        
        log_entry = f"[{timestamp}] [{level}] {message}"
        
        print(colors.get(level, Fore.WHITE) + log_entry + Fore.RESET)
        
        with open(self.log_file, "a", encoding=\'utf-8\') as f:
            f.write(log_entry + "\n")

def check_os_compatibility():
    """التحقق من توافق النظام"""
    system = platform.system()
    if system not in [\'Linux\', \'Windows\']:
        print(Fore.YELLOW + "Warning: This tool is primarily tested on Linux and Windows" + Fore.RESET)

if __name__ == "__main__":
    import argparse
    
    check_os_compatibility()
    
    parser = argparse.ArgumentParser(
        description="Vulnerability Scanner - Scan for common web vulnerabilities and open ports",
        epilog="Example: python vulnerability_scanner.py --target example.com --scan-ports"
    )
    parser.add_argument("--target", required=True, help="Target host (IP or URL)")
    parser.add_argument("--scan-ports", action="store_true", help="Scan common ports")
    parser.add_argument("--check-xss", action="store_true", help="Check for XSS vulnerability")
    parser.add_argument("--check-sqli", action="store_true", help="Check for SQL Injection vulnerability")
    
    args = parser.parse_args()
    
    scanner = VulnerabilityScanner()
    
    if args.scan_ports:
        scanner.scan_common_ports(args.target)
    
    if args.check_xss:
        scanner.check_xss(args.target)
        
    if args.check_sqli:
        scanner.check_sql_injection(args.target)


