# المشروع النهائي للأدوات الأمنية الأخلاقية بلغة Python مع التحسينات المطلوبة

سأقوم بتطبيق جميع التحسينات المطلوبة على المشروع مع الحفاظ على الهيكل الأساسي وإضافة جميع الميزات الجديدة. إليك المشروع النهائي المحسن:

## هيكل المشروع المحسن

```
/EthicalSecurityTools/
│
├── /tools/
│   ├── file_monitor.py
│   ├── malware_detector.py
│   ├── network_analyzer.py
│   ├── vulnerability_scanner.py
│   └── password_cracker.py
│
├── /docs/
│   ├── file_monitor_README.md
│   ├── malware_detector_README.md
│   ├── network_analyzer_README.md
│   ├── vulnerability_scanner_README.md
│   └── password_cracker_README.md
│
├── /tests/
│   ├── test_file_monitor.py
│   ├── test_malware_detector.py
│   ├── test_network_analyzer.py
│   ├── test_vulnerability_scanner.py
│   └── test_password_cracker.py
│
├── main.py
├── requirements.txt
├── setup.py
└── README.md
```

## 1. مراقب التغييرات في النظام (File Integrity Monitor) - المحسن

### ملف التوثيق (file_monitor_README.md)

```markdown
# مراقب التغييرات في النظام (File Integrity Monitor)

## الوصف
أداة لمراقبة سلامة الملفات عن طريق تتبع التغييرات في محتوى الملفات وسماتها.

## الميزات
- إنشاء بصمة هاش (SHA-256) للملفات
- الكشف عن التغييرات في الوقت الحقيقي
- تسجيل كافة الأحداث في ملف log
- دعم مراقبة الملفات الفردية أو المجلدات الكاملة

## المتطلبات
- Python 3.6+
- نظام تشغيل Windows/Linux

## طريقة الاستخدام
```bash
python main.py filemon <مسار الملف/المجلد>
```

## الأمثلة
```bash
# مراقبة مجلد كامل
python main.py filemon /var/www

# مراقبة ملف معين
python main.py filemon /etc/passwd
```

## معالجة الأخطاء
- يعالج الأداة أخطاء صلاحيات الملفات
- يسجل أخطاء القراءة/الكتابة
- يتعامل مع الملفات المؤقته

## الترخيص
هذا المشروع مرخص تحت رخصة MIT.
```

### الكود المحسن (file_monitor.py)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
مراقب التغييرات في النظام - File Integrity Monitor
إصدار: 2.0
"""

import hashlib
import os
import time
import platform
from pathlib import Path
from colorama import init, Fore

init()  # تهيئة colorama للألوان في الطرفية

class FileMonitor:
    def __init__(self, target_path):
        """
        تهيئة مراقب الملفات
        :param target_path: مسار الملف أو المجلد للمراقبة
        """
        self.target_path = Path(target_path).absolute()
        self.baseline = {}
        self.log_file = "file_monitor.log"
        self.os_type = platform.system()
        
        # إنشاء ملف السجل إذا لم يكن موجوداً
        if not Path(self.log_file).exists():
            with open(self.log_file, 'w') as f:
                f.write("File Integrity Monitor Log\n")
        
        self.log(f"Starting monitoring on {self.target_path}", "INFO")

    def calculate_hash(self, file_path):
        """
        حساب البصمة الرقمية للملف باستخدام SHA-256
        :param file_path: مسار الملف
        :return: البصمة الرقمية أو None في حالة الخطأ
        """
        try:
            with open(file_path, "rb") as f:
                file_hash = hashlib.sha256()
                while chunk := f.read(8192):  # قراءة الملف على شكل قطع للحفاظ على الذاكرة
                    file_hash.update(chunk)
                return file_hash.hexdigest()
        except PermissionError:
            self.log(f"Permission denied: {file_path}", "WARNING")
            return None
        except Exception as e:
            self.log(f"Error reading {file_path}: {str(e)}", "ERROR")
            return None
    
    def create_baseline(self):
        """إنشاء خط أساسي للبصمات الرقمية للملفات"""
        try:
            self.log("Creating baseline hashes...", "INFO")
            
            if self.target_path.is_file():
                file_hash = self.calculate_hash(self.target_path)
                if file_hash:
                    self.baseline[str(self.target_path)] = {
                        'hash': file_hash,
                        'size': self.target_path.stat().st_size,
                        'mtime': self.target_path.stat().st_mtime
                    }
            elif self.target_path.is_dir():
                for root, _, files in os.walk(self.target_path):
                    for file in files:
                        path = Path(root) / file
                        file_hash = self.calculate_hash(path)
                        if file_hash:
                            self.baseline[str(path)] = {
                                'hash': file_hash,
                                'size': path.stat().st_size,
                                'mtime': path.stat().st_mtime
                            }
            
            self.log(f"Baseline created with {len(self.baseline)} files", "SUCCESS")
            return True
        except Exception as e:
            self.log(f"Error creating baseline: {str(e)}", "ERROR")
            return False
    
    def monitor(self, interval=10):
        """
        بدء مراقبة التغييرات
        :param interval: الفترة الزمنية بين الفحوصات (بالثواني)
        """
        try:
            self.log(f"Starting monitoring with {interval} seconds interval", "INFO")
            
            while True:
                time.sleep(interval)
                current_state = {}
                changes_detected = False
                
                # مسح الملفات الحالية
                if self.target_path.is_file():
                    file_hash = self.calculate_hash(self.target_path)
                    if file_hash:
                        current_state[str(self.target_path)] = {
                            'hash': file_hash,
                            'size': self.target_path.stat().st_size,
                            'mtime': self.target_path.stat().st_mtime
                        }
                elif self.target_path.is_dir():
                    for root, _, files in os.walk(self.target_path):
                        for file in files:
                            path = Path(root) / file
                            file_hash = self.calculate_hash(path)
                            if file_hash:
                                current_state[str(path)] = {
                                    'hash': file_hash,
                                    'size': path.stat().st_size,
                                    'mtime': path.stat().st_mtime
                                }
                
                # الكشف عن الملفات الجديدة
                for file in current_state:
                    if file not in self.baseline:
                        self.log(f"New file detected: {file}", "WARNING")
                        changes_detected = True
                
                # الكشف عن الملفات المحذوفة
                for file in self.baseline:
                    if file not in current_state:
                        self.log(f"File deleted: {file}", "WARNING")
                        changes_detected = True
                
                # الكشف عن التغييرات في الملفات الموجودة
                for file in current_state:
                    if file in self.baseline:
                        old_data = self.baseline[file]
                        new_data = current_state[file]
                        
                        # الكشف عن تغيير المحتوى
                        if new_data['hash'] != old_data['hash']:
                            self.log(f"File content changed: {file}", "WARNING")
                            changes_detected = True
                        
                        # الكشف عن تغيير الحجم
                        elif new_data['size'] != old_data['size']:
                            self.log(f"File size changed: {file}", "WARNING")
                            changes_detected = True
                        
                        # الكشف عن تغيير وقت التعديل
                        elif new_data['mtime'] != old_data['mtime']:
                            self.log(f"File modification time changed: {file}", "WARNING")
                            changes_detected = True
                
                if changes_detected:
                    self.baseline = current_state  # تحديث الخط الأساسي
                
        except KeyboardInterrupt:
            self.log("Monitoring stopped by user", "INFO")
        except Exception as e:
            self.log(f"Monitoring error: {str(e)}", "ERROR")
    
    def log(self, message, level="INFO"):
        """تسجيل الأحداث مع تصنيف مستوى الخطورة"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        
        # ألوان حسب مستوى الخطورة
        colors = {
            "INFO": Fore.BLUE,
            "WARNING": Fore.YELLOW,
            "ERROR": Fore.RED,
            "SUCCESS": Fore.GREEN
        }
        
        log_entry = f"[{timestamp}] [{level}] {message}"
        
        # طباعة ملونة في الطرفية
        print(colors.get(level, Fore.WHITE) + log_entry + Fore.RESET)
        
        # تسجيل في الملف (بدون ألوان)
        with open(self.log_file, "a", encoding='utf-8') as f:
            f.write(log_entry + "\n")

def check_os_compatibility():
    """التحقق من توافق النظام"""
    system = platform.system()
    if system not in ['Linux', 'Windows']:
        print(Fore.YELLOW + "Warning: This tool is primarily tested on Linux and Windows" + Fore.RESET)

if __name__ == "__main__":
    import argparse
    
    check_os_compatibility()
    
    parser = argparse.ArgumentParser(
        description="File Integrity Monitor - Track changes to critical files",
        epilog="Example: python file_monitor.py /etc"
    )
    parser.add_argument("path", help="Path to file or directory to monitor")
    parser.add_argument("-i", "--interval", type=int, default=10,
                       help="Monitoring interval in seconds (default: 10)")
    
    args = parser.parse_args()
    
    monitor = FileMonitor(args.path)
    if monitor.create_baseline():
        monitor.monitor(args.interval)
```

## 2. كاشف البرمجيات الخبيثة (Malware Detector) - المحسن

### ملف التوثيق (malware_detector_README.md)

```markdown
# كاشف البرمجيات الخبيثة (Malware Detector)

## الوصف
أداة لاكتشاف البرمجيات الخبيثة باستخدام قواعد YARA والتوقيعات المحددة.

## الميزات
- مسح الملفات ضد قواعد YARA المخصصة
- كشف التوقيعات المعروفة للبرمجيات الخبيثة
- دعم المسح السريع للمجلدات الكاملة
- إمكانية تصدير النتائج بتنسيق JSON

## المتطلبات
- Python 3.6+
- yara-python (pip install yara-python)
- نظام تشغيل Windows/Linux

## طريقة الاستخدام
```bash
python main.py malware <المسار> --rules <مسار ملف القواعد>
```

## الأمثلة
```bash
# مسح ملف معين
python main.py malware suspicious.exe --rules malware_rules.yar

# مسح مجلد كامل
python main.py malware /downloads --rules malware_rules.yar
```

## معالجة الأخطاء
- يعالج أخطاء تحميل قواعد YARA
- يتعامل مع الملفات الكبيرة بشكل فعال
- يسجل الأخطاء في ملف log مخصص

## الترخيص
هذا المشروع مرخص تحت رخصة MIT.
```

### الكود المحسن (malware_detector.py)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
كاشف البرمجيات الخبيثة - Malware Detector
إصدار: 2.0
"""

import yara
import os
import json
import time
import platform
from pathlib import Path
from colorama import init, Fore

init()

class MalwareDetector:
    def __init__(self, rules_path):
        """
        تهيئة كاشف البرمجيات الخبيثة
        :param rules_path: مسار ملف قواعد YARA
        """
        self.rules_path = Path(rules_path)
        self.log_file = "malware_scan.log"
        self.os_type = platform.system()
        self.scan_stats = {
            'files_scanned': 0,
            'malware_detected': 0,
            'scan_time': 0,
            'start_time': time.time()
        }
        
        try:
            self.rules = yara.compile(filepath=str(self.rules_path))
            self.log("YARA rules loaded successfully", "SUCCESS")
        except yara.Error as e:
            self.log(f"Error loading YARA rules: {str(e)}", "ERROR")
            raise
        except Exception as e:
            self.log(f"Unexpected error: {str(e)}", "ERROR")
            raise
    
    def scan_file(self, file_path):
        """
        مسح ملف واحد للكشف عن البرمجيات الخبيثة
        :param file_path: مسار الملف للمسح
        :return: tuple (تم الكشف, النتائج)
        """
        self.scan_stats['files_scanned'] += 1
        
        try:
            matches = self.rules.match(filepath=str(file_path))
            if matches:
                result = {
                    'file': str(file_path),
                    'matches': [str(m) for m in matches],
                    'timestamp': time.strftime("%Y-%m-%d %H:%M:%S")
                }
                self.scan_stats['malware_detected'] += 1
                self.log(f"Malware detected in {file_path}: {matches}", "WARNING")
                return True, result
            return False, None
        except yara.Error as e:
            self.log(f"YARA error scanning {file_path}: {str(e)}", "ERROR")
            return False, str(e)
        except Exception as e:
            self.log(f"Error scanning {file_path}: {str(e)}", "ERROR")
            return False, str(e)
    
    def scan_directory(self, directory_path):
        """
        مسح مجلد كامل للكشف عن البرمجيات الخبيثة
        :param directory_path: مسار المجلد للمسح
        :return: قائمة بالملفات المصابة
        """
        infected_files = []
        directory_path = Path(directory_path)
        
        if not directory_path.exists():
            self.log(f"Directory not found: {directory_path}", "ERROR")
            return infected_files
        
        self.log(f"Scanning directory: {directory_path}", "INFO")
        
        try:
            for root, _, files in os.walk(directory_path):
                for file in files:
                    file_path = Path(root) / file
                    is_infected, result = self.scan_file(file_path)
                    if is_infected:
                        infected_files.append(result)
        except Exception as e:
            self.log(f"Directory scan error: {str(e)}", "ERROR")
        
        return infected_files
    
    def export_results(self, results, output_format="json"):
        """
        تصدير نتائج المسح
        :param results: نتائج المسح
        :param output_format: تنسيق التصدير (json/txt)
        """
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        output_file = f"malware_scan_results_{timestamp}.{output_format}"
        
        try:
            if output_format == "json":
                with open(output_file, 'w') as f:
                    json.dump(results, f, indent=2)
            else:  # txt
                with open(output_file, 'w') as f:
                    for result in results:
                        f.write(f"File: {result['file']}\n")
                        f.write("Matches:\n")
                        for match in result['matches']:
                            f.write(f"- {match}\n")
                        f.write("\n")
            
            self.log(f"Results exported to {output_file}", "SUCCESS")
            return output_file
        except Exception as e:
            self.log(f"Error exporting results: {str(e)}", "ERROR")
            return None
    
    def generate_report(self):
        """إنشاء تقرير عن نتائج المسح"""
        self.scan_stats['scan_time'] = time.time() - self.scan_stats['start_time']
        
        report = [
            "\n=== Malware Scan Report ===",
            f"Files scanned: {self.scan_stats['files_scanned']}",
            f"Malware detected: {self.scan_stats['malware_detected']}",
            f"Scan time: {self.scan_stats['scan_time']:.2f} seconds",
            "=== End of Report ==="
        ]
        
        for line in report:
            self.log(line, "INFO")
        
        return report
    
    def log(self, message, level="INFO"):
        """تسجيل الأحداث مع تصنيف مستوى الخطورة"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        
        colors = {
            "INFO": Fore.BLUE,
            "WARNING": Fore.YELLOW,
            "ERROR": Fore.RED,
            "SUCCESS": Fore.GREEN
        }
        
        log_entry = f"[{timestamp}] [{level}] {message}"
        
        print(colors.get(level, Fore.WHITE) + log_entry + Fore.RESET)
        
        with open(self.log_file, "a", encoding='utf-8') as f:
            f.write(log_entry + "\n")

def check_os_compatibility():
    """التحقق من توافق النظام"""
    system = platform.system()
    if system not in ['Linux', 'Windows']:
        print(Fore.YELLOW + "Warning: This tool is primarily tested on Linux and Wi
(Content truncated due to size limit. Use page ranges or line ranges to read remaining content)